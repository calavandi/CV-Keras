# -*- coding: utf-8 -*-
"""S4_First_DNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hh2sA_VmKzehGy11dJfyqJUA0uAH9236

# **Import Libraries and modules**

###Import Keras libraries
"""

# https://keras.io/
!pip install -q keras
import keras

"""###Importing other libraries needed"""

import numpy as np

from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten, Add
from keras.layers import Convolution2D, MaxPooling2D
from keras.utils import np_utils

from keras.datasets import mnist

"""### Load pre-shuffled MNIST data into train and test sets"""

(X_train, y_train), (X_test, y_test) = mnist.load_data()

"""###Print the image dimensions and plot the image"""

print (X_train.shape)
from matplotlib import pyplot as plt
# %matplotlib inline
plt.imshow(X_train[0])

"""###reshape the training and testing datasets"""

X_train = X_train.reshape(X_train.shape[0], 28, 28,1)
X_test = X_test.reshape(X_test.shape[0], 28, 28,1)

"""###Convert integer type data to float32 type and restrict data in betwwen 0-255 to 0-1 for both test and training data"""

X_train = X_train.astype('float32')
X_test = X_test.astype('float32')
X_train /= 255
X_test /= 255

"""###Display first 10 elements in the trainign dataset"""

y_train[:10]

# Convert 1-dimensional class arrays to 10-dimensional class matrices
Y_train = np_utils.to_categorical(y_train, 10)
Y_test = np_utils.to_categorical(y_test, 10)

Y_train[:10]

"""#The DNN
### The network is designed with one maxpooling and 5 convolution layers with a total of 14.9K parameters.
"""

from keras.layers import Activation
from keras.layers import Dropout
from keras.layers import MaxPool2D

model = Sequential()
 
model.add(Convolution2D(32, 3, 3, activation='relu', input_shape=(28,28,1))) #Will return 26x26x32


model.add(Convolution2D(16, 3, 3, activation='relu')) #returns 24x24x64

model.add(Convolution2D(16, 3, 3, activation='relu')) #returns 22x22x64

model.add(MaxPool2D(2,2)) #returns 11x11x64  --- 11x11x64

model.add(Convolution2D(8, 3, 3, activation = 'relu')) #9x9x16

model.add(Convolution2D(10, 9, 9))  #returns 1x1x10

model.add(Flatten())  #Runs flatten operation on the image matrix 
model.add(Activation('softmax'))

"""### Outputs the summary of our model"""

model.summary()

"""### Compiles the model and create a checkpoint callback which remembers the best accuracy achived in the training phase."""

from keras.callbacks import ModelCheckpoint
model.compile(loss='categorical_crossentropy',optimizer='adam',
             metrics=['accuracy'])
checkpoint = ModelCheckpoint('model.best-accuracy.hdfs', save_best_only=True,monitor='val_acc')
callback_list=[checkpoint]

"""### training the model and alsoo validate the model at each epoch against test data."""

model.fit(X_train, Y_train, batch_size=32, 
          nb_epoch=20, verbose=1, callbacks=callback_list, validation_data=(X_test, Y_test))

"""### Load the best model that was saved and evalute the model against the test data and record the score."""

#model.load_weights('model.best-accuracy.hdfs')
from keras.models import load_model
model = load_model('model.best-accuracy.hdfs')
score = model.evaluate(X_test, Y_test, verbose=0)

"""###Print  the score"""

print(score)

"""###predict the output on test data"""

y_pred = model.predict(X_test)

print(y_pred[:9])
print(y_test[:9])

layer_dict = dict([(layer.name, layer) for layer in model.layers])
print(layer_dict)

"""###This block of code shows us what the kernel sees in a particular layer that is passed to it and displays it.
###The textures and patterns that the kernel sees are printed in the output cell as shown.
"""

import numpy as np
from matplotlib import pyplot as plt
from keras import backend as K
# %matplotlib inline
# util function to convert a tensor into a valid image
def deprocess_image(x):
    # normalize tensor: center on 0., ensure std is 0.1
    x -= x.mean()
    x /= (x.std() + 1e-5)
    x *= 0.1

    # clip to [0, 1]
    x += 0.5
    x = np.clip(x, 0, 1)

    # convert to RGB array
    x *= 255
    #x = x.transpose((1, 2, 0))
    x = np.clip(x, 0, 255).astype('uint8')
    return x

def vis_img_in_filter(img = np.array(X_train[2]).reshape((1, 28, 28, 1)).astype(np.float64), 
                      layer_name = 'conv2d_3'):
    layer_output = layer_dict[layer_name].output
    img_ascs = list()
    for filter_index in range(layer_output.shape[3]):
        # build a loss function that maximizes the activation
        # of the nth filter of the layer considered
        loss = K.mean(layer_output[:, :, :, filter_index])

        # compute the gradient of the input picture wrt this loss
        grads = K.gradients(loss, model.input)[0]

        # normalization trick: we normalize the gradient
        grads /= (K.sqrt(K.mean(K.square(grads))) + 1e-5)

        # this function returns the loss and grads given the input picture
        iterate = K.function([model.input], [loss, grads])

        # step size for gradient ascent
        step = 5.

        img_asc = np.array(img)
        # run gradient ascent for 20 steps
        for i in range(20):
            loss_value, grads_value = iterate([img_asc])
            img_asc += grads_value * step

        img_asc = img_asc[0]
        img_ascs.append(deprocess_image(img_asc).reshape((28, 28)))
        
    if layer_output.shape[3] >= 35:
        plot_x, plot_y = 6, 6
    elif layer_output.shape[3] >= 23:
        plot_x, plot_y = 4, 6
    elif layer_output.shape[3] >= 11:
        plot_x, plot_y = 2, 6
    else:
        plot_x, plot_y = 1, 2
    fig, ax = plt.subplots(plot_x, plot_y, figsize = (12, 12))
    ax[0, 0].imshow(img.reshape((28, 28)), cmap = 'gray')
    ax[0, 0].set_title('Input image')
    fig.suptitle('Input image and %s filters' % (layer_name,))
    fig.tight_layout(pad = 0.3, rect = [0, 0, 0.9, 0.9])
    for (x, y) in [(i, j) for i in range(plot_x) for j in range(plot_y)]:
        if x == 0 and y == 0:
            continue
        ax[x, y].imshow(img_ascs[x * plot_y + y - 1], cmap = 'gray')
        ax[x, y].set_title('filter %d' % (x * plot_y + y - 1))

vis_img_in_filter()

